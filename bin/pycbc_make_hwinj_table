#! /usr/bin/env python

import argparse
import os
import shutil
from pycbc_hwinj import results
from glue import segments
from jinja2 import Environment, FileSystemLoader
from pycbc_hwinj.io import read_entry
from pycbc_hwinj.results.tables import table_row_keys, table_row_values
from pycbc_hwinj.types import HardwareInjection

PROTRACT_SEC = 300

def split_str(s, n):
    return [ s[i:i+n] for i in xrange(0, len(s), n) ]

# command line usage
parser = argparse.ArgumentParser(usage="pycbc_make_cal_workflow [--options]",
                                 description="Workflow generator for adjusting calibration model.")

# command line options
parser.add_argument("--start-time", type=int, required=True,
                    help="")
parser.add_argument("--end-time", type=int, required=True,
                    help="")
parser.add_argument("--csv-template", type=str, default="templates/hwinj_csv.html",
                    help="")
parser.add_argument("--html-template", type=str, default="templates/hwinj_table.html",
                    help="")
parser.add_argument("--output-csv-file", type=str, required=True,
                    help="")
parser.add_argument("--output-html-file", type=str, required=True,
                    help="")
parser.add_argument("--output-static-dir", type=str, required=True,
                    help="")
parser.add_argument("--segment-file", type=str, required=True,
                    help="")
parser.add_argument("--excitation-file", type=str, required=True,
                    help="")
parser.add_argument("--bitmask-file", type=str, required=True,
                    help="")
parser.add_argument("--gracedb-file", type=str, required=True,
                    help="")
parser.add_argument("--schedule-file", type=str, required=True,
                    help="")
parser.add_argument("--config-file", type=str, required=True,
                    help="")
parser.add_argument("--exclude-coinc-flags", nargs="+", type=str, default=["DMT-ANALYSIS_READY:1"],
                    help="")

# parse command line
opts = parser.parse_args()

# sanity checks
if not os.path.dirname(opts.output_html_file) == os.path.dirname(opts.output_csv_file):
    raise ValueError("HTML and CSV outputs must be in the same directory.")
if not os.path.dirname(opts.output_html_file) == os.path.dirname(opts.config_file):
    raise ValueError("HTML output and configuration file must be in the same directory.")

# get correct path to template files
if opts.html_template[0] != '/':
    html_template_path = results.__path__[0] + "/" + opts.html_template
else:
    html_template_path = opts.html_template
if opts.csv_template[0] != '/':
    csv_template_path = results.__path__[0] + "/" + opts.csv_template
else:
    csv_template_path = opts.csv_template

##### setup

# create a list to hold all the hardware injections
hwinj_list = []

# create lists to hold all segment, bitmask, and channel names
exc_names = []
seg_names = []
bitmask_names = []

# create list to hold all checks
check_names = HardwareInjection.check_dict.keys()
check_names.sort()

# time of analysis
analysis_time = segments.segment(opts.start_time, opts.end_time)

##### check_exc

# read excitation channel segments
fp = open(opts.excitation_file, "r")
lines = fp.readlines()
fp.close()

# loop over excitations found
for line in lines:

    # get segment from line
    line = line.rstrip("\n")
    entry = read_entry(line)
    channel_name = entry.channel_name
    ifo = channel_name.split(":")[0]
    seg = entry.segmentlist[0]
    channel_flag = channel_name[3:]

    # create a HardwareInjection and append to the list
    if seg in analysis_time:
        hwinj = HardwareInjection(ifo)
        hwinj.exc_dict[channel_flag] = segments.segmentlist([seg])
        hwinj_list.append(hwinj)

        # add to list of names if not already there
        if channel_flag not in exc_names:
            exc_names.append(channel_flag)

##### check_segdb

# read segdb segments
fp = open(opts.segment_file, "r")
lines = fp.readlines()
fp.close()

# loop over lines in segments file
tmp_list = []
for line in lines:

    # get segment from line
    line = line.rstrip("\n")
    entry = read_entry(line)
    segment_name = entry.channel_name
    ifo = segment_name.split(":")[0]
    seg = entry.segmentlist[0]
    segment_flag = segment_name[3:]

    # check if corresponding HardwareInjection exists
    match_found = False
    for hwinj in hwinj_list:
        if hwinj.ifo == ifo and hwinj.inj_seg(opts.exclude_coinc_flags).intersects_segment(seg):

            if segment_flag not in hwinj.seg_dict.keys():
                hwinj.seg_dict[segment_flag] = segments.segmentlist([seg])

                # add to list of names if not already there
                if segment_flag not in seg_names:
                    seg_names.append(segment_flag)

            else:
                hwinj.seg_dict[segment_flag].append(seg)
            match_found = True

    # if there was no corresponding HardwareInjection then make one 
    if not match_found and seg in analysis_time and segment_flag not in opts.exclude_coinc_flags:
        tmp_hwinj = HardwareInjection(ifo)
        tmp_hwinj.seg_dict[segment_flag] = segments.segmentlist([seg])
        tmp_list.append(tmp_hwinj)

        # add to list of names if not already there
        if segment_flag not in seg_names:
            seg_names.append(segment_flag)

# add new HardwareInjection to list
hwinj_list = hwinj_list + tmp_list

##### check_bitmask

# read bitmask segments
fp = open(opts.bitmask_file, "r")
lines = fp.readlines()
fp.close()

# loop over lines in bitmask segments files
tmp_list = []
for line in lines:

    # get segment from line
    line = line.rstrip("\n")
    entry = read_entry(line)
    channel_name = entry.channel_name
    ifo = channel_name.split(":")[0]
    seg = entry.segmentlist[0]
    bitmask_name = entry.description

    # check if injection exists
    match_found = False
    for hwinj in hwinj_list:
        if hwinj.ifo == ifo and hwinj.inj_seg(opts.exclude_coinc_flags).intersects_segment(seg):
            if bitmask_name not in hwinj.seg_dict.keys():
                hwinj.bitmask_dict[bitmask_name] = segments.segmentlist([seg])

                # add to list of names if not already there
                if bitmask_name not in bitmask_names:
                    bitmask_names.append(bitmask_name)

            else:
                hwinj.bitmask_dict[bitmask_name].append(seg)
            match_found = True

    # if there was no corresponding HardwareInjection then make one 
    if not match_found and seg in analysis_time and bitmask_name not in opts.exclude_coinc_flags:
        hwinj = HardwareInjection(ifo)
        hwinj.bitmask_dict[bitmask_name] = segments.segmentlist([seg])
        tmp_list.append(hwinj)

        # add to list of names if not already there
        if bitmask_name not in bitmask_names:
            bitmask_names.append(bitmask_name)

# add new HardwareInjection to list
hwinj_list = hwinj_list + tmp_list

##### check_schedule

# read schedule file
fp = open(opts.schedule_file, "r")
lines = fp.readlines()
fp.close()
schedule = [line.split() for line in lines]

# loop over entries in schedule
tmp_list = []
for entry in schedule:

    # check if schedule
    match_found = False
    for hwinj in hwinj_list:
        if float(entry[0]) in hwinj.inj_seg(opts.exclude_coinc_flags).protract(PROTRACT_SEC):
            hwinj.schedule_time = int(entry[0])
            hwinj.schedule_type = int(entry[1])
            hwinj.schedule_scale_factor = float(entry[2])
            hwinj.schedule_prefix = entry[3]
            match_found = True

    # if there was no corresponding HardwareInjection then make one 
    if not match_found and float(entry[0]) in analysis_time:
        hwinj = HardwareInjection("None")
        hwinj.schedule_time = int(entry[0])
        hwinj.schedule_type = int(entry[1])
        hwinj.schedule_scale_factor = float(entry[2])
        hwinj.schedule_prefix = entry[3]
        tmp_list.append(hwinj)

# add new HardwareInjection to list
hwinj_list = hwinj_list + tmp_list

##### check_gracedb

# read gracedb triggers
fp = open(opts.gracedb_file, "r")
lines = fp.readlines()
gracedb_trigs = [line.replace("\n", "").split(",") for line in lines]

# loop over gracedb triggers
tmp_list = []
for trig in gracedb_trigs:
    ifo_list = split_str(trig[3], 2)

    # check if gracedb trigger
    match_found = False
    for hwinj in hwinj_list:
        if trig[2] == "HardwareInjection" \
           and float(trig[1]) in hwinj.inj_seg(opts.exclude_coinc_flags).protract(PROTRACT_SEC) \
           and hwinj.ifo in ifo_list:
            hwinj.gracedb_id.append(trig[0])
            hwinj.gracedb_time.append(float(trig[1]))
            match_found = True

    # if there was no corresponding HardwareInjection then make one 
    if not match_found and trig[0].startswith("H") and float(trig[1]) in analysis_time:
        hwinj = HardwareInjection("None")
        hwinj.ifo = "".join(ifo_list)
        hwinj.gracedb_id.append(trig[0])
        hwinj.gracedb_time.append(float(trig[1]))
        tmp_list.append(hwinj)

# add new HardwareInjection to list
hwinj_list = hwinj_list + tmp_list

##### output

# render template
template_dir = os.path.dirname(html_template_path)
template_filename = os.path.basename(html_template_path)
env = Environment(loader=FileSystemLoader(template_dir))
env.globals.update(len=len)
env.globals.update(zip=zip)
env.globals.update(table_row_keys=table_row_keys)
env.globals.update(table_row_values=table_row_values)
env.globals.update(HardwareInjection=HardwareInjection)
template = env.get_template(template_filename)
context = {
    "analysis_time" : analysis_time,
    "csv_filename" : os.path.basename(opts.output_csv_file),
    "config_filename" : os.path.basename(opts.config_file),
    "hwinj_list" : hwinj_list,
    "exc_names" : exc_names,
    "seg_names" : seg_names,
    "bitmask_names" : bitmask_names,
    "check_names" : check_names,
}
html_output = template.render(context)

# write output
with open(opts.output_html_file, "w") as fp:
    fp.write(html_output)

# render template
template_dir = os.path.dirname(csv_template_path)
template_filename = os.path.basename(csv_template_path)
env = Environment(loader=FileSystemLoader(template_dir))
env.globals.update(map=map)
env.globals.update(str=str)
env.globals.update(table_row_keys=table_row_keys)
env.globals.update(table_row_values=table_row_values)
env.globals.update(HardwareInjection=HardwareInjection)
template = env.get_template(template_filename)
context = {
    "hwinj_list" : hwinj_list,
    "exc_names" : exc_names,
    "seg_names" : seg_names,
    "bitmask_names" : bitmask_names,
    "check_names" : check_names,
}
csv_output = template.render(context)

# write output
with open(opts.output_csv_file, "w") as fp:
    fp.write(csv_output)

# copy statis files to html directory
static_dir = results.__path__[0] + '/static/'
if not os.path.exists(opts.output_static_dir):
    shutil.copytree(static_dir, opts.output_static_dir)

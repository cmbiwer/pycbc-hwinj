#! /usr/bin/env python

import argparse
import os
import shutil
from pycbc_hwinj import results
from glue import segments
from jinja2 import Environment, FileSystemLoader

class HardwareInjection(object):
    """ Class that represents a hardware injection.
    """

    def __init__(self, ifo):

        # set a string to idenity IFO
        self.ifo = ifo

        # a dict that holds all excitation segments
        self.exc_dict = segments.segmentlistdict()

        # a dict that holds all segments from the segdb
        self.seg_dict = segments.segmentlistdict()

        # a dict that holds all segments from bitmasked channels
        self.bitmask_dict = segments.segmentlistdict()

        # GraceDB information about hardware injection
        self.gracedb_id = []
        self.gracedb_time = []

        # schedule information about hardware injection
        self.schedule_time = None
        self.schedule_type = None
        self.schedule_scale_factor = None
        self.schedule_prefix = None

    def __repr__(self):
        return " ".join(map(str, [self.ifo, self.gracedb_id, self.gracedb_time,
                        self.exc_dict, self.seg_dict, self.bitmask_dict,
                        self.schedule_entry]))

    @property
    def schedule_entry(self):
        """ Returns line from schedule file.
        """

        return " ".join(map(str, [self.schedule_time, self.schedule_type,
                                  self.schedule_scale_factor, self.schedule_prefix]))

    @property
    def inj_seg(self, observation_segment_flag="DMT-ANALYSIS_READY:1"):
        """ Returns a segmnetlist that is the union of all excitation,
        segdb and bitmasked channels.
        """

        tmp_list = segments.segmentlist([])
        tmp_list
        for seg_list in self.exc_dict.values():
            tmp_list.extend(seg_list)
            tmp_list
        for key in self.seg_dict.keys():
            if key != observation_segment_flag:
                tmp_list.extend(self.seg_dict[key])
                tmp_list
        for seg_list in self.bitmask_dict.values():
            tmp_list.extend(seg_list)
            tmp_list
        if self.schedule_time:
            seg = segments.segment(self.schedule_time, self.schedule_time + 1)
            seg_list = segments.segmentlist([seg])
            tmp_list.extend(seg_list)
        for time in self.gracedb_time:
            seg = segments.segment(time, time + 1)
            seg_list = segments.segmentlist([seg])
            tmp_list.extend(seg_list)
        return tmp_list

    def check_single_excitation(self):
        """ Logical check that there was only one excitation at the time.
        """
        if len(self.exc_dict.keys()) > 1:
            return False
        for key in self.exc_dict.keys():
            if len(self.exc_dict[key]) > 1:
                return False
        return True

    # a dict that defines all checks for HardwareInjection
    check_dict = {
        "Single excitation recorded" : check_single_excitation,
    }

def table_row_keys(exc_keys, seg_keys, bitmask_keys, check_keys):
    """ Returns a list of column labels.
    """

    cols = ["IFO", "GraceDB IDs", "GraceDB Times", "All checks passed"]
    for key in check_keys:
        cols.append(key)
    for key in exc_keys:
        cols.append("Excitations from "+key)
    for key in seg_keys:
        cols.append("Segments from "+key)
    for key in bitmask_keys:
        cols.append("Bitmask segments from "+key)
    cols.append("Schedule")
    return cols

def table_row_values(hwinj, exc_keys, seg_keys, bitmask_keys, check_keys):
    """ Returns a list of column values for a HardwareInjection.
    """

    cols = [hwinj.ifo] 
    cols.append(" ".join([str(id) for id in hwinj.gracedb_id]))
    cols.append(" ".join([str(time) for time in hwinj.gracedb_time]))
    all_checks_str = ""
    for key in check_keys:
        if not hwinj.check_dict[key](hwinj):
            all_checks_str = ""
            break
        all_checks_str = "&#10004"
    cols.append(all_checks_str)
    for key in check_keys:
        if hwinj.check_dict[key](hwinj):
            cols.append("&#10004")
        else:
            cols.append("")
    for key in exc_keys:
        if key in hwinj.exc_dict.keys():
            seg_list = hwinj.exc_dict[key]
            seg_str = ""
            for seg in seg_list:
                seg_str += "-".join(map(str, seg))
                if seg != seg_list[-1]:
                    seg_str += " "
        else:
            seg_str = "None"
        cols.append(seg_str)
    for key in seg_keys:
        if key in hwinj.seg_dict.keys():
            seg_list = hwinj.seg_dict[key]
            seg_str = ""
            for seg in seg_list:
                seg_str += "-".join(map(str, seg))
                if seg != seg_list[-1]:
                     seg_str += " "
        else:
            seg_str = "None"
        cols.append(seg_str)
    for key in bitmask_keys:
        if key in hwinj.bitmask_dict.keys():
            seg_list = hwinj.bitmask_dict[key]
            seg_str = ""
            for seg in seg_list:
                seg_str += "-".join(map(str, seg))
                if seg != seg_list[-1]:
                    seg_str += " "
        else:
            seg_str = "None"
        cols.append(seg_str)
    cols.append(hwinj.schedule_entry)
    return cols

# command line usage
parser = argparse.ArgumentParser(usage="pycbc_make_cal_workflow [--options]",
                                 description="Workflow generator for adjusting calibration model.")

# command line options
parser.add_argument("--start-time", type=int, required=True,
                    help="")
parser.add_argument("--end-time", type=int, required=True,
                    help="")
parser.add_argument("--csv-template", type=str, default="templates/hwinj_csv.html",
                    help="")
parser.add_argument("--html-template", type=str, default="templates/hwinj_table.html",
                    help="")
parser.add_argument("--output-csv-file", type=str, required=True,
                    help="")
parser.add_argument("--output-html-file", type=str, required=True,
                    help="")
parser.add_argument("--segment-file", type=str, required=True,
                    help="")
parser.add_argument("--excitation-file", type=str, required=True,
                    help="")
parser.add_argument("--bitmask-file", type=str, required=True,
                    help="")
parser.add_argument("--gracedb-file", type=str, required=True,
                    help="")
parser.add_argument("--schedule-file", type=str, required=True,
                    help="")
parser.add_argument("--config-file", type=str, required=True,
                    help="")
parser.add_argument("--observation-segment-flag", type=str, default="DMT-ANALYSIS_READY:1",
                    help="")

# parse command line
opts = parser.parse_args()

# sanity checks
if not os.path.dirname(opts.output_html_file) == os.path.dirname(opts.output_csv_file):
    raise ValueError("HTML and CSV outputs must be in the same directory.")
if not os.path.dirname(opts.output_html_file) == os.path.dirname(opts.config_file):
    raise ValueError("HTML output and configuration file must be in the same directory.")

# get correct path to template files
if opts.html_template[0] != '/':
    html_template_path = results.__path__[0] + "/" + opts.html_template
else:
    html_template_path = opts.html_template
if opts.csv_template[0] != '/':
    csv_template_path = results.__path__[0] + "/" + opts.csv_template
else:
    csv_template_path = opts.csv_template

##### setup

# create a list to hold all the hardware injections
hwinj_list = []

# create lists to hold all segment, bitmask, and channel names
exc_names = []
seg_names = []
bitmask_names = []

# create list to hold all checks
check_names = HardwareInjection.check_dict.keys()
check_names.sort()

# time of analysis
analysis_time = segments.segment(opts.start_time, opts.end_time)

##### check_exc

# read excitation channel segments
fp = open(opts.excitation_file, "r")
lines = fp.readlines()
fp.close()

# loop over excitations found
for line in lines:

    # get segment from line
    data = line.replace("\n", "").split(",")
    channel_name = data[0]
    ifo = channel_name.split(":")[0]
    seg = segments.segment(float(data[1]), float(data[2]))
    channel_flag = channel_name[3:]

    # create a HardwareInjection and append to the list
    if seg in analysis_time:
        hwinj = HardwareInjection(ifo)
        hwinj.exc_dict[channel_flag] = segments.segmentlist([seg])
        hwinj_list.append(hwinj)

        # add to list of names if not already there
        if channel_flag not in exc_names:
            exc_names.append(channel_flag)

##### check_segdb

# read segdb segments
fp = open(opts.segment_file, "r")
lines = fp.readlines()
fp.close()

# loop over lines in segments file
tmp_list = []
for line in lines:

    # get segment from line
    data = line.replace("\n", "").split(",")
    segment_name = data[0]
    ifo = segment_name.split(":")[0]
    seg = segments.segment(float(data[1]), float(data[2]))
    segment_flag = segment_name[3:]

    # check if corresponding HardwareInjection exists
    match_found = False
    for hwinj in hwinj_list:
        if hwinj.ifo == ifo and hwinj.inj_seg.intersects_segment(seg):

            if segment_flag not in hwinj.seg_dict.keys():
                hwinj.seg_dict[segment_flag] = segments.segmentlist([seg])

                # add to list of names if not already there
                if segment_flag not in seg_names:
                    seg_names.append(segment_flag)

            else:
                hwinj.seg_dict[segment_flag].append(seg)
            match_found = True

#            if segment_flag != opts.observation_segment_flag:
#                break

    # if there was no corresponding HardwareInjection then make one 
    if not match_found and seg in analysis_time and segment_flag != opts.observation_segment_flag:
        tmp_hwinj = HardwareInjection(ifo)
        tmp_hwinj.seg_dict[segment_flag] = segments.segmentlist([seg])
        tmp_list.append(tmp_hwinj)

        # add to list of names if not already there
        if segment_flag not in seg_names:
            seg_names.append(segment_flag)

# add new HardwareInjection to list
hwinj_list = hwinj_list + tmp_list

##### check_bitmask

# read bitmask segments
fp = open(opts.bitmask_file, "r")
lines = fp.readlines()
fp.close()

# loop over lines in bitmask segments files
tmp_list = []
for line in lines:

    # get segment from line
    data = line.replace("\n", "").split(",")
    channel_name = data[0]
    bitmask_name = data[1]
    ifo = channel_name.split(":")[0]
    seg = segments.segment(float(data[3]), float(data[4]))

    # check if injection exists
    match_found = False
    for hwinj in hwinj_list:
        if hwinj.ifo == ifo and hwinj.inj_seg.intersects_segment(seg):
            if bitmask_name not in hwinj.seg_dict.keys():
                hwinj.bitmask_dict[bitmask_name] = segments.segmentlist([seg])

                # add to list of names if not already there
                if bitmask_name not in bitmask_names:
                    bitmask_names.append(bitmask_name)

            else:
                hwinj.bitmask_dict[bitmask_name].append(seg)
            match_found = True
            break

    # if there was no corresponding HardwareInjection then make one 
    if not match_found and seg in analysis_time:
        hwinj = HardwareInjection(ifo)
        hwinj.bitmask_dict[bitmask_name] = segments.segmentlist([seg])
        tmp_list.append(hwinj)

        # add to list of names if not already there
        if bitmask_name not in bitmask_names:
            bitmask_names.append(bitmask_name)

# add new HardwareInjection to list
hwinj_list = hwinj_list + tmp_list

##### check_schedule

# read schedule file
fp = open(opts.schedule_file, "r")
lines = fp.readlines()
fp.close()
schedule = [line.split() for line in lines]

# loop over entries in schedule
tmp_list = []
for entry in schedule:

    # check if schedule
    match_found = False
    for hwinj in hwinj_list:
        if float(entry[0]) in hwinj.inj_seg.protract(600):
            hwinj.schedule_time = int(entry[0])
            hwinj.schedule_type = int(entry[1])
            hwinj.schedule_scale_factor = float(entry[2])
            hwinj.schedule_prefix = entry[3]
            match_found = True

    # if there was no corresponding HardwareInjection then make one 
    if not match_found and float(entry[0]) in analysis_time:
        hwinj = HardwareInjection("None")
        hwinj.schedule_time = int(entry[0])
        hwinj.schedule_type = int(entry[1])
        hwinj.schedule_scale_factor = float(entry[2])
        hwinj.schedule_prefix = entry[3]
        tmp_list.append(hwinj)

# add new HardwareInjection to list
hwinj_list = hwinj_list + tmp_list

##### check_gracedb

# read gracedb triggers
gracedb_trigs = []
fp = open(opts.gracedb_file, "r")
lines = fp.readlines()
gracedb_trigs = [line.replace("\n", "").split(",") for line in lines]

# loop over gracedb triggers
tmp_list = []
for trig in gracedb_trigs:

    # check if gracedb trigger
    match_found = None
    for hwinj in hwinj_list:
        if hwinj.inj_seg:
            if trig[2] == "HardwareInjection" \
               and float(trig[1]) in hwinj.inj_seg.protract(600):
                hwinj.gracedb_id.append(trig[0])
                hwinj.gracedb_time.append(float(trig[1]))
                match_found = True

    # if there was no corresponding HardwareInjection then make one 
    if not match_found and trig[0].startswith("H") and float(trig[1]) in analysis_time:
        hwinj = HardwareInjection("None")
        hwinj.gracedb_id.append(trig[0])
        hwinj.gracedb_time.append(float(trig[1]))
        tmp_list.append(hwinj)

# add new HardwareInjection to list
hwinj_list = hwinj_list + tmp_list

##### output

# render template
template_dir = os.path.dirname(html_template_path)
template_filename = os.path.basename(html_template_path)
env = Environment(loader=FileSystemLoader(template_dir))
env.globals.update(len=len)
env.globals.update(zip=zip)
env.globals.update(table_row_keys=table_row_keys)
env.globals.update(table_row_values=table_row_values)
env.globals.update(HardwareInjection=HardwareInjection)
template = env.get_template(template_filename)
context = {"analysis_time" : analysis_time,
           "csv_filename" : os.path.basename(opts.output_csv_file),
           "config_filename" : os.path.basename(opts.config_file),
           "hwinj_list" : hwinj_list,
           "exc_names" : exc_names,
           "seg_names" : seg_names,
           "bitmask_names" : bitmask_names,
           "check_names" : check_names}
html_output = template.render(context)

# write output
with open(opts.output_html_file, "w") as fp:
    fp.write(html_output)

# render template
template_dir = os.path.dirname(csv_template_path)
template_filename = os.path.basename(csv_template_path)
env = Environment(loader=FileSystemLoader(template_dir))
env.globals.update(map=map)
env.globals.update(str=str)
env.globals.update(table_row_keys=table_row_keys)
env.globals.update(table_row_values=table_row_values)
env.globals.update(HardwareInjection=HardwareInjection)
template = env.get_template(template_filename)
context = {"hwinj_list" : hwinj_list,
           "exc_names" : exc_names,
           "seg_names" : seg_names,
           "bitmask_names" : bitmask_names,
           "check_names" : check_names}
csv_output = template.render(context)

# write output
with open(opts.output_csv_file, "w") as fp:
    fp.write(csv_output)

# copy statis files to html directory
static_dir = results.__path__[0] + '/static'
static_output_dir = os.path.dirname(opts.output_html_file) + '/static'
if not os.path.exists(static_output_dir):
    shutil.copytree(static_dir, static_output_dir)

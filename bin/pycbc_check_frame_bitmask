#! /usr/bin/env python

import argparse
import sys
import numpy as np
from glue import segments
from glue.segmentsUtils import from_bitstream
from itertools import groupby
from math import ceil, floor
from operator import itemgetter
from pycbc.frame import read_frame

# command line usage
parser = argparse.ArgumentParser(usage="pycbc_check_frame_bitmask [--options]",
                                 description="Apply bitmask to channel and get for segments.")

# command line options
parser.add_argument("--frame-files", type=str, nargs="+", required=True,
                    help="Frame files to read.")
parser.add_argument("--frame-type", type=str,
                    help="Frame type of frame files.")
parser.add_argument("--channel-name", type=str, required=True,
                    help="Channel name to read.")
parser.add_argument("--bitmask", type=int, required=True,
                    help="Bitmask to use.")
parser.add_argument("--bitmask-name", type=str, required=True,
                    help="A string that describes the bitmask.")
parser.add_argument("--start-time", type=int, required=True,
                    help="GPS time to start reading data.")
parser.add_argument("--end-time", type=int, required=True,
                    help="GPS time to stop reading data.")
parser.add_argument("--output-file", type=str, required=True,
                    help="Output file with segments.")
parser.add_argument("--flip-bits", action="store_true",
                    help="Takes 1 minus the value of the channel.")
parser.add_argument("--pad-seconds", type=float, default=0.1,
                    help="Seconds to pad segments when finding union.")

# parse command line
opts = parser.parse_args()

# read ODC channel
try:
    data = read_frame(opts.frame_files, opts.channel_name, opts.start_time, opts.end_time)
except RuntimeError:
    fp = open(opts.output_file, "w")
    fp.close()
    sys.exit()

# typecast as integer
if data.dtype in [np.float32]:
    data = data.astype(np.uint32) 

# use bitmask
bits = ( data.numpy() & opts.bitmask ) == opts.bitmask

# if want not of the channel data
if opts.flip_bits:
    bits = 1 - bits

# get segments where bit is active
segs = from_bitstream(bits, data.start_time, data.delta_t)
segs = segments.segmentlist([segments.segment(seg[0], seg[1]) for seg in segs])
segs.coalesce()

# pad segments by a fraction of a second
segs = segments.segmentlist([seg.protract(opts.pad_seconds) for seg in segs])

# find the union of segments
segs.coalesce()
segs.contract(opts.pad_seconds)

# write segments to file
with open(opts.output_file, "w") as fp:
    for seg in segs:
        line = ",".join(map(str, [opts.channel_name, opts.bitmask_name, opts.bitmask, seg[0], seg[1]])) + "\n"
        fp.write(line)
